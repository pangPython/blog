### 联机重做日志恢复
- 状态不同，比较复杂
- 日志切换伴随着检查点的出现（及时脏数据写磁盘，让日志释放掉，此操作滞后于日志切换）
- active表示，虽然不用当前日志组，但是当前日志组不允许出现问题
- active与是否归档没有关系
- 检查点完成之后，active->inactive

### 恢复日志组
#### 丢失一个成员（底线）
  - 有互为镜像的成员，但此时的可靠性已经下降了
#### 丢失一组日志
  - 严重，数据库无法正常工作，立即崩溃
#### 丢失inactive日志组
  - shutdown abort
  - 空文件，问题不严重
#### 丢失current日志组
##### 正常关闭数据库
    - shutdown immediate
    - rm file
    - startup mount
    - 如何判断是否是正常关闭？
      - 看日志
        - 日志记录正常关闭
        - 本次启动时alter database open--beginning crash recovery--崩溃恢复
    - 对当前数据库没有影响，但是对备份恢复策略有影响，导致归档日志不连续，需要下次启动数据库是立即做全备份
##### 非正常关闭数据库
    - 不一致，必须借助当前日志组进行实例恢复，只能回退数据库，回退到上一次一致的时候，日志切换时，在上一次检查点
    - 检查日志时，非正常关闭且current日志组出现问题。
    - 回退到上一次inactive阶段，不完全恢复，整个数据库往回退。
    - 恢复到set until sequence n-1 (n为出故障的日志组)
#### 丢失active日志组
  - 当启动数据库时，发现存在active状态的日志组文件，说明上一次数据库没有正常关闭
  - 损失更严重
  - 恢复到set until sequence n (n为出故障的日志组)
    - 有备份
    - 无备份
### 可能丢失一组日志的场景（不允许出现）
  - 组里只有一个成员
  - 组里有多个成员，但在同一个硬盘

检查点严重滞后，日志没有inactive状态
新添加的成员，虽然互为镜像，还没有被使用时是空的，
### 强制把脏数据写回磁盘 alter database checkpoint;

### 平时写预案
### 书：Oracle RMAN
